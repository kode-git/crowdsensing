<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <link rel="stylesheet" href="http://cdn.leafletjs.com/leaflet-0.7/leaflet.css" />
    <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/4.0.0/css/bootstrap.min.css" integrity="sha384-Gn5384xqQ1aoWXA+058RXPxPg6fy4IWvTNh0E263XmFcJlSAwiGgFAW/dAiS6JXm" crossorigin="anonymous">
    <script src="http://cdn.leafletjs.com/leaflet-0.7.3/leaflet.js"></script>
    <script src="https://ajax.googleapis.com/ajax/libs/jquery/3.5.1/jquery.min.js"></script>
    <script src='https://api.tiles.mapbox.com/mapbox.js/v1.6.4/mapbox.js'></script>
    <script src="/static/js/leaflet-heat.js"></script>
    <scritp src="./leaflet.ajax.min.js"></script>
    
    <style type="text/css">
    #map-wrapper {
    width: 100%;
    height: 500px;
    position: relative;
    border: 1px solid black;
    }

    #map {
    width: 100%;
    height: 100%;
    }

    #button-wrapper {
    position: absolute;
    bottom: -220px;
    width: 100%;
    margin-left: 20px;
    }
    </style>
</head>

<body>
<div class="span9" style="height:100%">
    
    <div id="map-wrapper">
        <div id="map"></div>
        <div id="button-wrapper">
            <button class="btn btn-primary" type="submit" id="marker">Show Noise Markers</button>
            <button class="btn btn-primary" type="submit" id="heatmap">Show Noise Heatmap</button>
            <button class="btn btn-primary" type="submit" id="clustering">Show Noise Clustering</button>
            <button class="btn btn-primary" type="submit" id="request">POST REQUEST</button>
            <div class="slidecontainer" min="0" max="10" value="2" step="10">
                <input type="range" min="1" max="50" value="15" step="0.1" class="slider" id="blur">
                <input type="range" min="1" max="85" value="25" step="0.1" class="slider" id="radius">
              </div>
              <p>Select a map type:</p>

                <div>
                <input type="radio" id="mapnik" name="drone" value="mapnik"
                        checked>
                <label for="huey">OpenStreetMap Mapnik</label>
                </div>

                <div>
                <input type="radio" id="stadia" name="drone" value="stadia">
                <label for="dewey">Stadia Alidade Smooth Dark</label>
                </div>

                <div>
                <input type="radio" id="thunder" name="drone" value="thunder">
                <label for="louie">Thunder Forest Transport</label>
                </div>   
            </div> 
        
    </div>
  </div>

<script type="text/javascript">

    //Get current position
    var options = {
    enableHighAccuracy: true,
    timeout: 5000,
    maximumAge: 0
    };

    var map = L.map('map');
    L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
        maxZoom: 19,
        attribution: '&copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors'
    }).addTo(map);

    map.locate({setView: true, maxZoom: 16});
    var latitudine;
    var longitudine;
    function onLocationFound(e) {
        latitudine=e.latitude;
        longitudine=e.longitude;
        console.log(e.latitude+' .... ' +e.longitude);
    }

    map.on('locationfound', onLocationFound);

    let marker;
    let heat;
    const heatmaplayer = new L.layerGroup();
    const markerlayer = new L.layerGroup();
    markerLayers = [];
    const clusterlayer = new L.layerGroup();
    clusterLayers = [];
    const vertexlayer = new L.layerGroup();
    vertexLayers = [];
    heatmapLayers=[];
    var heatMap=0;


    $("#marker").on("click", e=>{
        e.preventDefault();
        $.ajax({
            url: "/getLocations",
            type: "POST",
            dataType: "json",
            
            success: function(data){
               
                var geojsonMarkerOptions = {
                    radius: 10,
                    fillColor: "#0f8bff",
                    color: "#000",
                    weight: 1,
                    opacity: 1,
                    fillOpacity: 0.8
                };

                marker=L.geoJson(data, {
                    pointToLayer: function (feature, latlng) {
                        return L.circleMarker(latlng, geojsonMarkerOptions);
                    },onEachFeature: function (feature, layer) {
                        layer.bindPopup('<p>Latitude: '+feature.geometry.coordinates[1]+'</p> <p>Longitude: '+feature.geometry.coordinates[0]+'\n </p>');
                    }

                });

                markerlayer.clearLayers();
                heatmaplayer.clearLayers();
                clusterlayer.clearLayers();
                vertexlayer.clearLayers();
                markerlayer.addLayer(marker);
                map.addLayer(markerlayer);    
            }
        });
    });

    


    $("#heatmap").on("click", e=>{
        e.preventDefault();
        $.ajax({
            url: "/getLocations",
            type: "POST",
            dataType: "json",
            
            success: function(data){
               var geoData = geoJson2heat(data, 1);
                heatMap = new L.heatLayer(geoData,{max: 1});
                clusterlayer.clearLayers();
                vertexlayer.clearLayers();
                markerlayer.clearLayers();
                heatmaplayer.clearLayers();
                
                heatmaplayer.addLayer(heatMap);
                
                map.addLayer(heatmaplayer);
            }
                
        });
    });
   
 // CLUSTERING
   
    $("#clustering").on("click", e=>{
        e.preventDefault();
    //map.on('zoomend', function() {
    //    console.log(map.getZoom());
        $.ajax({
                type: 'POST',
                url: '/showClustering',
                dataType: 'json',
                data: {
                    k: parseInt(map.getZoom())
                },

                success: function(data){
                    clusterlayer.clearLayers();
                    vertexlayer.clearLayers();
                    markerlayer.clearLayers();
                    heatmaplayer.clearLayers();

                    console.log(data);
                    for(let i=0;i<parseInt(map.getZoom());i++){
                        
                        //console.log(getColor(data.centroids[i].properties.db));
                        var geojsonPolygonOptions = {
                                fillColor: getColor(data.centroids[i].properties.db),
                                weight: 2,
                                opacity: 2,
                                color: 'black',
                                dashArray: '3',
                                fillOpacity: 0.5
                                
                            };

                        var geojsonMarkerOptions = {
                               fillColor: getColor(data.centroids[i].properties.db),
                               weight: 2,
                               opacity: 1000,
                               color: 'black',
                               fillOpacity: 0.5      
                            };

                        //POLYGONS
                        var polygon = L.polygon(data.clusters[i].geometry.coordinates,geojsonPolygonOptions);
                        
                        //CENTROIDS
                        var lat=data.centroids[i].geometry.coordinates[0];
                        var lng=data.centroids[i].geometry.coordinates[1];
                        var latlng = new L.latLng(lat,lng);
                            
                        var centroid = L.circleMarker(latlng,geojsonMarkerOptions);
                        
                        //Centroids and polygons layers
                        clusterlayer.addLayer(polygon);
                        clusterlayer.addLayer(centroid);

                        for(let j=0; j<data.clusters[i].geometry.coordinates.length;j++){
                            
                            
                            var lat=data.clusters[i].geometry.coordinates[j][0];
                            var lng=data.clusters[i].geometry.coordinates[j][1];
                            var latlng = new L.latLng(lat,lng);
                            
                            var geojsonMarkerOptions = {
                                radius: 4,
                                fillColor: getColor(data.centroids[i].properties.db),
                                color: "#000",
                                weight: 1,
                                opacity: 1,
                                fillOpacity: 0.8
                            };


                            var vertex = L.circleMarker(latlng,geojsonMarkerOptions);
                            vertexlayer.addLayer(vertex);

                        }
                }                
                map.addLayer(clusterlayer);    
                map.addLayer(vertexlayer);
                }
            })
        });



// Convert DB in a color shade from green to red
function getColor(value) {  
    var hue=((value - 20) * 100) / (40 - 20)
    h=hue;
    s=100;
    l=50/100;
    const a = s * Math.min(l, 1 - l) / 100;
    const f = n => {
        const k = (n + h / 30) % 12;
        const color = l - a * Math.max(Math.min(k - 3, 9 - k, 1), -1);
        return Math.round(255 * color).toString(16).padStart(2, '0');   // convert to Hex and prefix "0" if needed
    };
    return `#${f(0)}${f(8)}${f(4)}`;
}


    

  

//SET GEOJSON FOR HEATMAP FUNCTION
geoJson2heat = function(geojson) {
    return geojson.features.map(function(feature) {
    return [parseFloat(feature.geometry.coordinates[1]), parseFloat(feature.geometry.coordinates[0]),feature.properties.db];
    });
}



//HEATMAP BLUR SLIDER
var blurslider=document.getElementById("blur");
blurslider.oninput=function(){
    heatMap.setOptions({
        blur: parseInt(this.value)
    });
    // render the new options
    heatMap.redraw();
}

//HEATMAP RADIUS SLIDER
var radiusslider=document.getElementById("radius");
radiusslider.oninput=function(){
   heatMap.setOptions({
        radius: parseInt(this.value)
    });
     // render the new options
    heatMap.redraw();
}


//MAP STYLE RADIO BUTTON
$('input[type="radio"]').on('click',function(){
     var value = $(this).val();
     
     var name = $(this).attr('value');
     if(value=='mapnik'){
     L.tileLayer('https://{s}.tile.openstreetmap.de/tiles/osmde/{z}/{x}/{y}.png', {
	maxZoom: 18,
	attribution: '&copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors'
}).addTo(map);
}else if(value=='thunder'){
    var Thunderforest_Transport = L.tileLayer('https://{s}.tile.thunderforest.com/transport/{z}/{x}/{y}.png?apikey={apikey}', {
	attribution: '&copy; <a href="http://www.thunderforest.com/">Thunderforest</a>, &copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors',
	apikey: '4d975f2a48924ef0beda223fc08d16ef',
	maxZoom: 22
}).addTo(map);
}else if(value=='stadia'){
    var Stadia_AlidadeSmoothDark = L.tileLayer('https://tiles.stadiamaps.com/tiles/alidade_smooth_dark/{z}/{x}/{y}{r}.png', {
	maxZoom: 20,
    r:'f7bbae07-5f38-4731-92c2-3f977975be0a',
	attribution: '&copy; <a href="https://stadiamaps.com/">Stadia Maps</a>, &copy; <a href="https://openmaptiles.org/">OpenMapTiles</a> &copy; <a href="http://openstreetmap.org">OpenStreetMap</a> contributors'
}).addTo(map);
 
}
});

//



</script>
</body>
</html>